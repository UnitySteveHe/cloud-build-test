#if UNITY_INCLUDE_TESTS
using NUnit.Framework;
using System;
using System.Collections;
using System.Collections.Generic;
using Unity.AutomatedQA;
using Unity.RecordedPlayback;
#if UNITY_EDITOR
using UnityEditor;
#endif
using UnityEngine;
using UnityEngine.EventSystems;
using UnityEngine.SceneManagement;
using UnityEngine.TestTools;

namespace GeneratedRecordedTests
{
    public abstract class AutomatedQATestsBase
    {
        private int sceneCount = 0;
        protected RunContext Test
        {
            get
            {
                if (_test == null)
                    _test = new RunContext();
                return _test;
            }
            set => _test = value;
        }
        private RunContext _test;
        protected RecordingInputModule.InputModuleRecordingData recordingData { get; set; }
        protected List<RecordingInputModule.TouchData> Steps = new List<RecordingInputModule.TouchData>();
        private static (int index, RecordingInputModule.TouchData touch) LastRecordedAction;
        protected virtual void SetUpTestClass() { }
        protected virtual void SetUpTestRun() { }

        private RecordingInputModule Instance => RecordingInputModule.Instance;

        protected void RegisterStep(RecordingInputModule.TouchData data)
        {
            Steps.Add(data);
            Instance.AddTouchData(data);
        }

        [UnitySetUp]
        public IEnumerator SetUpSingleTest()
        {
#if UNITY_EDITOR
            if (!playModeStateChangeListenerSet)
            {
                playModeStateChangeListenerSet = true;
                EditorApplication.playModeStateChanged += OnPlayModeStateChanged;
            }
#endif
            ReportingManager.IsTestWithoutRecordingFile = true;
            Screen.sleepTimeout = SleepTimeout.NeverSleep;

            SetUpTestRun();
            recordingData = new RecordingInputModule.InputModuleRecordingData();
            recordingData.entryScene = Test.entryScene;
            recordingData.recordedAspectRatio = Test.recordedAspectRatio;
            recordingData.recordedResolution = Test.recordedResolution;
            recordingData.recordingType = RecordingInputModule.InputModuleRecordingData.type.single;
            ReportingManager.CurrentTestName = $"{TestContext.CurrentContext.Test.ClassName}.{TestContext.CurrentContext.Test.Name}";
            ReportingManager.InitializeReport();
            ReportingManager.InitializeDataForNewTest();

            // Set up recording data
            RecordedPlaybackPersistentData.SetRecordingData(recordingData);

            // Start playback
            CentralAutomationController.Instance.Reset();
            CentralAutomationController.Instance.AddAutomator<RecordedPlaybackAutomator>();
            CentralAutomationController.Instance.Run();

            // Wait for RecordingInputModule to initialize
            var startTime = DateTime.UtcNow;
            int timeoutSecs = 60;
            while (Instance == null)
            {
                if (DateTime.UtcNow.Subtract(startTime).TotalSeconds >= timeoutSecs)
                {
                    Debug.LogError($"Timeout wile waiting for RecordingInputModule to initialize");
                    break;
                }
                yield return null;
            }

            Instance.ClearTouchData();
            SetUpTestClass();
        }

        public static RecordingInputModule.TouchData EMIT_COMPLETE = new RecordingInputModule.TouchData
        {
            pointerId = -1,
            eventType = RecordingInputModule.TouchData.type.none,
            timeDelta = 2f,
            position = new Vector3(0, 0),
            positional = false,
            waitSignal = "",
            emitSignal = "playbackComplete",
            objectName = "",
            objectTag = "",
            objectHierarchy = "",
            objectOffset = new Vector3(0, 0)
        };

        protected class RunContext
        {
            public string entryScene;
            public Vector2 recordedAspectRatio;
            public Vector2 recordedResolution;
        }

        protected bool AnyErrors()
        {
            return ReportingManager.ReportData.AllLogs.FindAll(x => x.Type.ToLower() == "error" || x.Type.ToLower() == "exception").Any();
        }

        protected string GetError(string stepInfo)
        {
            if (AnyErrors())
            {
                ReportingManager.Log log = ReportingManager.ReportData.AllLogs.FindAll(x => x.Type.ToLower() == "error" || x.Type.ToLower() == "exception").Last();
                return $"{log.Message}{(log.StackTrace.Length > 0 ? $" [StackTrace: \n{log.StackTrace}]" : string.Empty)}";
            }
            return $"No errors or exceptions are generated by {stepInfo}";
        }

        [UnityTearDown]
        protected virtual IEnumerator UnityTearDown()
        {
            ReportingManager.IsTestWithoutRecordingFile = false;
            if (CentralAutomationController.Exists())
            {
                CentralAutomationController.Instance.Reset();
            }
            ReportingManager.CreateMonitoringService();
            var emptyScene = SceneManager.CreateScene("emptyscene" + sceneCount++);
            SceneManager.SetActiveScene(emptyScene);
            yield return UnloadScenesExcept(emptyScene.name);
        }

        /// <summary>
        /// Grabs the requested step's index, and waits until the step is executed.
        /// </summary>
        /// <param name="action"></param>
        /// <returns></returns>
        protected IEnumerator PerformAction(RecordingInputModule.TouchData action)
        {
            if (action == EMIT_COMPLETE)
            {
                Instance.AddTouchData(EMIT_COMPLETE);
                Steps.Add(EMIT_COMPLETE);
            }
            int index = Instance.GetTouchData().FindIndex(x => x == action);

            /*
                The InterpolateDragEvents method adds multiple TouchData events (not part of a recording) to "smooth" a drag between two points.
                These dynamically-generated events were added when drag start was invoked (previous DoAction call). We need to adjust our requested index based on this behavior.
            */
            if (LastRecordedAction != default((int, RecordingInputModule.TouchData)) &&
                LastRecordedAction.touch.eventType == RecordingInputModule.TouchData.type.drag)
            {
                yield return PerformInterpolatedDragActions(LastRecordedAction.index + 1, index - LastRecordedAction.index);
            }
            LastRecordedAction = (index, action);

            float timeout = AutomatedQARuntimeSettings.DynamicWaitTimeout;
            while (!Instance.UpdatePlay(index) && timeout > 0)
            {
                yield return new WaitForEndOfFrame();
                timeout -= Time.deltaTime;
            }

            Assert.IsTrue(!AnyErrors(), GetError($"{action.scene}: {action.objectHierarchy}"));
        }

        protected IEnumerator PerformInterpolatedDragActions(int startIndex, int interpolatedEventCount)
        {
            for (int x = 0; x < interpolatedEventCount; x++)
            {
                while (!Instance.UpdatePlay(startIndex + x))
                    yield return new WaitForEndOfFrame();
            }
        }

        protected IEnumerator WaitFor(Func<bool> condition, float timeout = 30f)
        {
            float timer = 0;
            while (!condition.Invoke() && timer <= timeout)
            {

                float start = Time.realtimeSinceStartup;
                while (Time.realtimeSinceStartup < start + 1f)
                {

                    yield return null;

                }
                timer++;

            }
            yield return null;
        }

        private IEnumerable UnloadScenesExcept(string sceneName)
        {
            int sceneCount = SceneManager.sceneCount;
            for (int i = 0; i < sceneCount; i++)
            {
                Scene scene = SceneManager.GetSceneAt(i);
                if (scene.name != sceneName)
                {
                    var unloadSceneAsync = SceneManager.UnloadSceneAsync(scene);
                    while (!unloadSceneAsync.isDone)
                    {
                        yield return null;
                    }
                }
            }
        }

#if UNITY_EDITOR
        private static bool playModeStateChangeListenerSet = false;
        public void OnPlayModeStateChanged(PlayModeStateChange state)
        {
            if (state == PlayModeStateChange.ExitingPlayMode || state == PlayModeStateChange.EnteredEditMode)
            {
                ReportingManager.FinalizeReport();
            }
        }
#endif
    }
}
#endif